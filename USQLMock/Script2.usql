//CREATE ASSEMBLY IF NOT EXISTS [Newtonsoft.Json] FROM "/Newtonsoft.Json.dll";
//CREATE ASSEMBLY IF NOT EXISTS [Microsoft.Analytics.Samples.Formats] FROM "/Microsoft.Analytics.Samples.Formats.dll";

REFERENCE ASSEMBLY [Newtonsoft.Json.dll];
REFERENCE ASSEMBLY [Microsoft.Analytics.Samples.Formats.dll];

DECLARE @INPUT_FILE string = @"/Samples/Data/cake.json";


//Extract the different properties from the Json file using a JsonExtractor
@json =
    EXTRACT id string, type string, name string, ppu string, batters string, topping string
    FROM @INPUT_FILE
    USING new Microsoft.Analytics.Samples.Formats.Json.JsonExtractor();


/*
Batters and Toppings have nested Json in them, this script extracts the nested Json as SQL.MAPs and then gets their values in a SQL.ARRAY
*/
@parsebatterandtopping =
    SELECT id,
           type ,
           name ,
           ppu ,
           Microsoft.Analytics.Samples.Formats.Json.JsonFunctions.JsonTuple(batters, "batter[*]").Values AS batter_arr,
           Microsoft.Analytics.Samples.Formats.Json.JsonFunctions.JsonTuple(topping).Values AS topping_arr
    FROM @json;

/*
Use CROSS APPLY to generate a cartesian product of the various batters and toppings
*/
@cake_types =
    SELECT id,
           type,
           name,
           ppu,
           Microsoft.Analytics.Samples.Formats.Json.JsonFunctions.JsonTuple(b_value) ["type"]AS batter,
           Microsoft.Analytics.Samples.Formats.Json.JsonFunctions.JsonTuple(t_value) ["type"]AS topping
    FROM @parsebatterandtopping
         CROSS APPLY
             EXPLODE(batter_arr) AS t(b_value)
         CROSS APPLY
             EXPLODE(topping_arr) AS T(t_value);

OUTPUT @cake_types
TO "/Samples/Output/caketypes.csv"
USING Outputters.Csv(quoting : false);